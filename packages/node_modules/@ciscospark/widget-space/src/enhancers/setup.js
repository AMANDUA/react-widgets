import {compose, lifecycle} from 'recompose';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';

import {fetchAvatar} from '@ciscospark/redux-module-avatar';
import {resetErrors} from '@ciscospark/redux-module-errors';
import {connectToMercury} from '@ciscospark/redux-module-mercury';
import {fetchSpace} from '@ciscospark/redux-module-spaces';
import {getUser} from '@ciscospark/redux-module-users';
import {constructHydraId, hydraTypes, isUuid, validateAndDecodeId} from '@ciscospark/react-component-utils';

import {
  getSpaceDetails,
  reloadWidget,
  storeDestination,
  updateWidgetStatus
} from '../actions';

import {getSpaceWidgetProps} from '../selector';

import {destinationTypes} from '../';

/**
 * Normalizes destination id to either email or hydra id
 *
 * @param {string} destination.id
 * @param {string} destination.type
 * @returns {string}
 */
function normalizeDestinationId({id, type}) {
  if (type === destinationTypes.USERID) {
    let destinationId = id;

    if (isUuid(id)) {
      destinationId = constructHydraId(hydraTypes.PEOPLE, id);
    }

    return destinationId;
  }
  if (type === destinationTypes.SPACEID) {
    let destinationId = id;

    if (isUuid(id)) {
      destinationId = constructHydraId(hydraTypes.ROOM, id);
    }

    return destinationId;
  }

  return id;
}

/**
 * Converts props into a destination object
 *
 * @param {*} props
 * @returns {Object} destination
 * @returns {string} destination.id
 * @returns {string} destination.type
 * @returns {string} destination.warning
 */
function getDestinationFromProps(props) {
  const {
    destinationId,
    destinationType
  } = props;

  if (destinationType && destinationId) {
    return {type: destinationType, id: normalizeDestinationId({type: destinationType, id: destinationId})};
  }

  return null;
}

function setup(props, prevProps) {
  const {
    conversation,
    destination,
    errors,
    sparkInstance,
    sparkState,
    spaceDetails,
    widgetStatus,
    mercuryStatus,
    users,
    spaces
  } = props;

  if (sparkInstance
    && sparkState.get('authenticated')
    && sparkState.get('registered')
    && !sparkState.get('hasError')
  ) {
    // Check if we need to reload space
    if (widgetStatus.shouldReloadWidget && prevProps && !prevProps.widgetStatus.shouldReloadWidget) {
      props.reloadWidget();
      props.resetErrors();
    }

    // Check for destination Change
    if (destination && prevProps.destination) {
      const calculatedDestination = getDestinationFromProps(props);
      const calculatedPreviousDestination = getDestinationFromProps(prevProps);

      if (
        calculatedPreviousDestination.id !== calculatedDestination.id
        || calculatedPreviousDestination.type !== calculatedDestination.type
      ) {
        sparkInstance.logger.info('Destination has changed, widget reloading...');
        props.updateWidgetStatus({
          shouldReloadWidget: true
        });
      }
    }

    // Connect to websocket (mercury)
    if (!mercuryStatus.hasConnected
      && !mercuryStatus.connecting
      && !mercuryStatus.connected
      && sparkInstance.internal.device.registered) {
      props.connectToMercury(sparkInstance);
    }

    // Get space details for given destination
    if (!widgetStatus.isFetchingSpaceDetails && !errors.get('hasError') && !spaceDetails) {
      // If the selector isn't returning a destination object and we have props for them, store
      if (destination) {
        // Use destination object from store to fetch space details
        // Instead of using props because of legacy prop support
        props.getSpaceDetails({
          sparkInstance,
          destinationId: destination.id,
          destinationType: destination.type,
          intl: props.intl
        });
        // Fetch 1:1 User details
        if (destination.type === destinationTypes.EMAIL && !users.getIn(['byEmail', destination.id])) {
          props.getUser({email: destination.id}, sparkInstance);
        }
        if (destination.type === destinationTypes.USERID && !users.getIn(['byId', destination.id])) {
          props.getUser({id: destination.id}, sparkInstance);
        }
        if (destination.type === destinationTypes.SPACEID && !spaces.getIn(['byId', validateAndDecodeId(destination.id)])) {
          props.fetchSpace(sparkInstance, validateAndDecodeId(destination.id));
        }
      }
      else {
        const calculatedDestination = getDestinationFromProps(props);

        if (calculatedDestination.warning) {
          sparkInstance.logger.warn(calculatedDestination.warning);
        }
        props.storeDestination(calculatedDestination);
      }
    }

    if (conversation.get('id')) {
      props.fetchAvatar({space: conversation.toJS()}, sparkInstance);
    }
  }
}

export default compose(
  connect(
    getSpaceWidgetProps,
    (dispatch) => bindActionCreators({
      connectToMercury,
      fetchSpace,
      getUser,
      getSpaceDetails,
      reloadWidget,
      resetErrors,
      storeDestination,
      updateWidgetStatus,
      fetchAvatar
    }, dispatch)
  ),
  lifecycle({
    componentWillMount() {
      setup(this.props);
    },
    shouldComponentUpdate(nextProps) {
      return nextProps !== this.props;
    },
    componentWillReceiveProps(nextProps) {
      setup(nextProps, this.props);
    }
  })
);
